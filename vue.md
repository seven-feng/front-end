### MVVM

Model–View–ViewModel (MVVM) 是一种软件架构设计模式

Model 层，模型层，后端传递的数据

View 层，视图层，前端展示

ViewModel 层，视图模型层，用于连接 View 层和 Model 层。一方面，实现了与 View 层的双向绑定，通过数据驱动视图，一方面，又与 Model 层进行交互，解耦了 View 层和 Model 层

 

双向绑定，实现数据视图自动更新，不再操作 DOM 对象，专注于业务逻辑

解耦了 View 层和 Model 层，目的在于实现前后端分离

&emsp;

### Vue 优势

1. 通过虚拟 DOM 减少 DOM 操作

   虚拟 DOM 采用 js 对象模拟一颗简单的 DOM 树，任何 DOM 操作都会在 VNode 上进行，最后新旧 VNode 进行对比（优化），一次性将比较结果更新到 DOM 树上。由于不需要频繁操作 DOM，大大提高了性能。

2. 双向数据绑定

   Vue 基于 MVVM 架构。在 MVVM 中， View 层和 Model 层不能直接通信，需要通过 ViewModel 层进行连接。当数据发生变化时，ViewModel 监听数据变化，更新视图；当用户操作视图时，ViewModel 监听视图变化，通知数据改动。Vue 实现双向数据绑定，可以让开发者不再操作 DOM 对象，专注于业务逻辑。

3. 组件化开发

   Vue 允许我们使用小型、独立和可复用的组件来构建应用。

   优点：组件高内聚低耦合，便于测试和复用

   ​			开发易于管理和协同，提高开发效率

> 发现两种双向数据绑定的理解：一种是 View 层和 ViewModel 层的绑定，一种是 View 层和 Model 层的绑定。其实，两个都有道理，前者适用于 Vue 框架，而后者基于整个 MVVM 架构。

&emsp;

### created 和 mounted 的区别

#### created

在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图

#### mounted

在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作

&emsp;

### 组件的生命周期

#### 父子组件

![vue-lifecycle1](assets/vue-lifecycle1.png)

#### 继承组件

![vue-lifecycle2](assets/vue-lifecycle2.png)

&emsp;

### vue 原理

vue.js 采用数据劫持结合发布-订阅模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调

> 属性描述符：数据描述符和存取描述符

&emsp;

### 虚拟DOM

用 js 对象模拟 DOM 节点，用户交互时操作虚拟 DOM，然后通过 diff 算法比较操作前后的虚拟 DOM，最后将 diff 结果更新到实际 DOM 上

&emsp;

### vuex 缺陷

没有持久化存储的手段，每次刷新都会重置所有的数据

&emsp;

看 vue 源码心得：

1. 数据对象是数组时，数组的索引是非响应式的

   ~~~js
   vm = new Vue({
     data: {
       arr: [1, 2]
     }
   })
   
   vm.arr[0] = 3  // 不能触发响应
   vm.arr.push(4) // 出发响应
   ~~~

   对数组的处理，都是通过拦截数组的变异方法实现的
   
2. 数组的索引是非响应式的原因

   Vue 中通过对对象每个键设置 getter 和 setter 来实现响应式。使用数组的目的往往是遍历，但是调用 getter 开销太大，所以 Vue 不在数组的每个键上定义响应式。
   
3. el 选项提供一个在页面上已经存在的 DOM 元素作为 Vue 实例的挂载目标（挂载点），挂载的元素会被 Vue 生成的 DOM 替换。

4. `Watcher` 的原理是通过对“被观测目标”（expOrFn）的求值，触发数据属性的 `get` 拦截器函数从而收集依赖。

   如果 `expOrFn` 中包含多个数据属性，执行 `expOrFn` 时会触发这些数据属性的 `get` 拦截器函数将当前观察者收集为依赖，即**一个观察者对象对应多个数据属性**

   如果对某个数据属性进行观察（Vue 的 watch 选项或者 vm.$watch），实际上就是定义了 `Watcher` 对象，会触发该数据属性的 `get` 拦截器函数收集依赖，结合上面的情况，即**一个数据属性对应多个观察者对象**
   
5. 读取数据属性的值，能够触发该属性的 get 拦截函数，从而收集依赖。但是其子属性是没有被读取的，所以也不能够收集依赖，千万要和定义响应式区分开来。

6. 如果计算属性 `compA` 依赖了数据对象的 `a` 属性，那么属性 `a` 将收集计算属性 `compA` 的 **计算属性观察者对象**，而 **计算属性观察者对象** 将收集 **渲染函数观察者对象**，实际上是属性`a`收集了**渲染函数观察者对象**，所以改变属性`a`的值，会触发渲染函数重新执行。