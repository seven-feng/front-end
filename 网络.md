#### HTTP 状态码

HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：

**信息响应**（1xx）

**成功响应**（2xx）

​	200 OK

**重定向**（3xx）

​	301 Moved Permanently

​	304 Not Modified

**客户端错误**（4xx）

​	400 Bad Request

​	404 Not Found

**服务器错误**（5xx）

​	500 Internal Server Error

​	504 Gateway Timeout



#### HTTP Request Body

HTTP 请求的 body 主要用于提交表单场景。实际上，HTTP 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是：

- application/json
- application/x-www-form-urlencoded
- multipart/form-data
- text/xml

我们使用 HTML 的 form 标签提交产生的 HTML 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。

![HTTP-Body-1](assets/HTTP-Body-1.png)

HTTP body 的格式一般定义在 Content-type 中，如上图，body 的格式是 application/json，请求体中的数据也是 json 格式的。



然而，在开发过程中，我曾经遇到这样一个问题：在 POST 请求中，采用 application/json 格式提交数据，后端接收不到（后端用对象接收数据），最后采用 application/x-www-form-urlencoded 格式，即提交表单方式解决了问题。

![HTTP-Body-2](assets/HTTP-Body-2.png)

​	

#### HTTP **缓存**

#### HTTP/1.0 、HTTP/1.1、 HTTP/2

在 HTTP/1.0 中，一个 http 请求在收到服务器响应后，会断开对应的 TCP 连接，所以每次请求都需要重新建立 TCP 连接，比较耗时。通过设置头字段 Connection: keep-alive，可以在 http 请求完成后，继续使用当前连接进行通信。

HTTP/1.1 将 Connection 写入了标准，默认值为 keep-alive。除非强制设置为 Connection: close，才会在请求完成后断开 TCP 连接。



HTTP/1.1 中，单个 TCP 连接，在同一时间只能处理一个 http 请求。

HTTP/2 提供了多路传输功能，多个 http 请求，可以同时在同一个 TCP 连接中进行传输。



**并发性**

页面资源请求时，浏览器会同时和服务器建立多个 TCP 连接，在同一个 TCP 连接上顺序处理多个HTTP请求。所以浏览器的并发性就体现在可以建立多个 TCP 连接，来支持多个 http 同时请求。

Chrome浏览器最多允许对同一个域名 Host 建立 **6** 个 TCP 连接，不同的浏览器有所区别。



#### TCP 和 UDP

##### 区别

1. TCP 面向连接，UDP 无连接
2. TCP 提供可靠数据传输，UDP 尽最大努力交付
3. TCP 传输速度慢且有序，UDP 传输速度快且无序

 ##### 具体应用场景

TCP 用于金融领域，如 FIX 协议

UDP 用于娱乐游戏领域，如在线视频，在线游戏

 ##### 位于哪一层

位于传输层



#### GET 和 POST

##### 区别

1. GET 请求参数通过 URL 传递，而 POST 放在请求体中
2. GET 请求中 URL 长度是有限制的，而 POST 没有
3. GET 请求会被浏览器主动缓存（cache），而 POST 不会
4. GET 请求产生一个TCP数据包，而 POST 产生两个TCP数据包

 ##### 传输大小限制

浏览器和 web 服务器限制了 URL 的最大长度

（浏览器通常都会限制 URL 长度在2K个字节）

##### POST 比 GET 更安全

1. GET 请求参数会出现在 URL 上面
2. GET 请求会被浏览器缓存，可以在浏览器历史或 web 服务器日志中找到

