#### HTTP 状态码

HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：

**信息响应**（1xx）

**成功响应**（2xx）

​	200 OK

**重定向**（3xx）

​	301 Moved Permanently

​	304 Not Modified

**客户端错误**（4xx）

​	400 Bad Request

​	404 Not Found

**服务器错误**（5xx）

​	500 Internal Server Error

​	504 Gateway Timeout



#### HTTP Request Body

HTTP 请求的 body 主要用于提交表单场景。实际上，HTTP 请求的 body 是比较自由的，只要浏览器端发送的 body 服务端认可就可以了。一些常见的 body 格式是：

- application/json
- application/x-www-form-urlencoded
- multipart/form-data
- text/xml

我们使用 HTML 的 form 标签提交产生的 HTML 请求，默认会产生 application/x-www-form-urlencoded 的数据格式，当有文件上传时，则会使用 multipart/form-data。

![HTTP-Body-1](assets/HTTP-Body-1.png)

HTTP body 的格式一般定义在 Content-type 中，如上图，body 的格式是 application/json，请求体中的数据也是 json 格式的。



然而，在开发过程中，我曾经遇到这样一个问题：在 POST 请求中，采用 application/json 格式提交数据，后端接收不到（后端用对象接收数据），最后采用 application/x-www-form-urlencoded 格式，即提交表单方式解决了问题。

![HTTP-Body-2](assets/HTTP-Body-2.png)

​	

#### HTTP **缓存**

![HTTP-Body-2](assets/HTTP-Cache.png)

浏览器请求资源时，先检查本地是否有缓存，如果有缓存且没有过期，则直接从缓存获取，如果过期，则向服务器发送请求。服务器收到请求后，会验证缓存资源是否有更新，如果有更新，则返回最新的资源，如果没有更新，就返回304（刷新缓存新鲜度，如age=0），直接从缓存获取

> age：资源在缓存中贮存的时长



**强缓存**：获取该资源缓存的 header 信息，判断是否过期（Cache-Control、Expires），若没有过期，就直接从缓存中获取资源，包括缓存的 header 信息

>  Cache-Control 是 HTTP/1.1 中的字段，主要是利用该字段的 max-age 值来进行判断
>
> Expires 是 HTTP/1.0 中的字段，它的值为一个GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT



**协商缓存**：第一次请求的响应头带某个字段（ETag、Last-Modified），后续请求的请求头会带上对应的字段（If-None-Match、If-Modified-Since），服务器以此判断缓存资源是否可用

> ETag 是资源特定版本的标识符
>
> Last-Modified 是一个 GMT 格式的时间字符串



|          | 获取资源形式 | 状态码               | 发送请求到服务器               |
| -------- | ------------ | -------------------- | ------------------------------ |
| 强缓存   | 从缓存获取   | 200 ( from cache )   | 否，直接从缓存获取             |
| 协商缓存 | 从缓存获取   | 304 ( not modified ) | 是，通过服务器告知缓存是否可用 |



**HTTP/1.1 中用 Cache-Control 替代 Expires**

1. Cache-Control 更加具体，常用字段：max-age、private、public、no-store、no-cache
2. Expires 定义了失效时间，但是可能存在客户端时间和服务端时间不一致的情况



**Last-Modified 的不足之处**

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET
2. 某些文件修改非常频繁，比如在秒级以下的时间内进行修改(比方说1s内修改了N次)，If-Modified-Since 能检查到的粒度是秒级的，对这种修改无法判断
3. 某些服务器不能精确的得到文件的最后修改时间

 

Last-Modified 与 ETag 是可以一起使用的，服务器会**优先验证 ETag**



#### HTTP/1.0 、HTTP/1.1、 HTTP/2

在 HTTP/1.0 中，一个 http 请求在收到服务器响应后，会断开对应的 TCP 连接，所以每次请求都需要重新建立 TCP 连接，比较耗时。通过设置头字段 Connection: keep-alive，可以在 http 请求完成后，继续使用当前连接进行通信。

HTTP/1.1 将 Connection 写入了标准，默认值为 keep-alive。除非强制设置为 Connection: close，才会在请求完成后断开 TCP 连接。



HTTP/1.1 中，单个 TCP 连接，在同一时间只能处理一个 http 请求。

HTTP/2 提供了多路传输功能，多个 http 请求，可以同时在同一个 TCP 连接中进行传输。



**并发性**

页面资源请求时，浏览器会同时和服务器建立多个 TCP 连接，在同一个 TCP 连接上顺序处理多个HTTP请求。所以浏览器的并发性就体现在可以建立多个 TCP 连接，来支持多个 http 同时请求。

Chrome浏览器最多允许对同一个域名 Host 建立 **6** 个 TCP 连接，不同的浏览器有所区别。



#### TCP 和 UDP

##### 区别

1. TCP 面向连接，UDP 无连接
2. TCP 提供可靠数据传输，UDP 尽最大努力交付
3. TCP 传输速度慢且有序，UDP 传输速度快且无序

 ##### 具体应用场景

TCP 用于金融领域，如 FIX 协议

UDP 用于娱乐游戏领域，如在线视频，在线游戏

 ##### 位于哪一层

位于传输层



#### GET 和 POST

##### 区别

1. GET 请求参数通过 URL 传递，而 POST 放在请求体中
2. GET 请求中 URL 长度是有限制的，而 POST 没有
3. GET 请求会被浏览器主动缓存（cache），而 POST 不会
4. GET 请求产生一个TCP数据包，而 POST 产生两个TCP数据包

 ##### 传输大小限制

浏览器和 web 服务器限制了 URL 的最大长度

（浏览器通常都会限制 URL 长度在2K个字节）

##### POST 比 GET 更安全

1. GET 请求参数会出现在 URL 上面
2. GET 请求会被浏览器缓存，可以在浏览器历史或 web 服务器日志中找到

