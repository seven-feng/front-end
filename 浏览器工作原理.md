## 宏观视角下的浏览器

### Chrome 架构

![chrome-framework](assets/chrome-framework.png)

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。 

- **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 
- **渲染进程**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 
- **GPU 进程**：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 
- **网络进程**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 
- **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 

&emsp;

### HTTP 请求流程

![chrome-http](assets/chrome-http.png)

&emsp;

### 导航流程

从输入 URL 到页面展示完整流程示意图

![chrome-navigate](assets/chrome-navigate.png)

#### 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。 
- 如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。

&emsp;

当用户输入关键字并键入回车之后，浏览器便进入下图的加载状态：

![chrome-loading](assets/chrome-loading.png)

但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。 

&emsp;

#### URL 请求过程

接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。具体流程同上 **HTTP 请求流程**。

1. 重定向

   在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求。 

2. 响应数据类型处理

   Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。 

   如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程 。

&emsp;

#### 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。 

Chrome 的默认策略是，每个标签页对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于**同一站点**的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。 

> 同一站点（same-site）：具有相同的**协议**（例如，http:// 或者 https://）和**根域名**（例如，geekbang.org）

 渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。 

&emsp;

#### 提交文档

 首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。 

- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

更新内容如下图所示：

![chrome-update](assets/chrome-update.png)

 这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。 

&emsp;

#### 渲染阶段

 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示： 

![chrome-render](assets/chrome-render.png)

至此，一个完整的页面就生成了。

&emsp;

### 渲染流程

整个渲染流程，包括 DOM 生成、样式计算、布局、图层、绘制、光栅化、合成和显示。

下图是完整的渲染流水线示意图：

![chrome-render-flow](assets/chrome-render-flow.png)

1. 渲染进程将 HTML 内容转换为浏览器能够读懂的 **DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成**位图**。
7. 合成线程发送绘制图块命令 **DrawQuad** 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成**页面，并**显示**到显示器上。

> 渲染引擎就是渲染进程
>
> 7 GPU 内存中的位图是否需要合成？
>
> 8 浏览器进程将最终要显示的位图提交到操作系统？

&emsp;

#### 更新了元素的几何属性（重排）

![chrome-reset](assets/chrome-reset.png)

从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。



#### 更新元素的绘制属性（重绘）

![chrome-repaint](assets/chrome-repaint.png)

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫**重绘**。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

&emsp;

#### 直接合成阶段

![chrome-compound](assets/chrome-compound.png)

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

&emsp;

## 浏览器中的 JavaScript 执行机制

### 变量提升

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 **undefined**。 

&emsp;

#### JavaScript 代码的执行流程

![JS-execute-flow](assets/JS-execute-flow.png)

JavaScript 代码在执行之前需要先编译，在编译阶段，变量和函数会被存放到**变量环境**中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。

![JS-execute-flow-detail](assets/JS-execute-flow-detail.png)

从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：**执行上下文**（Execution context）和**可执行代码**。

**执行上下文**是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。 

在执行上下文中存在一个**变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。 

可以简单地把变量环境对象看成是如下结构：

~~~javascript
VariableEnvironment:
     myname -> undefined, 
     showName ->function : {console.log(myname)

~~~

&emsp;

当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。一般说来，有这么三种情况：

1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

&emsp;

### 调用栈

#### 函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面我们看个简单的示例代码：

~~~ javascript
var a = 2
function add(){
	var b = 10
	return  a+b
}
add()
~~~

在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，可以参考下图：

![JS-global-execute-context](assets/JS-global-execute-context.png)

执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作： 

- 首先，从全局执行上下文中，取出 add 函数代码。
- 其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。
- 最后，执行代码，输出结果。

&emsp;

完整流程你可以参考下图：

![JS-function-call-flow](assets/JS-function-call-flow.png)



#### 调用栈

调用栈是 JavaScript 引擎用来管理执行上下文的。

![JS-call-stack](assets/JS-call-stack.png)

- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

&emsp;

### 块级作用域

#### 作用域（scope）

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。 

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。 

- **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。 
- **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。 

还有一种作用域，

**块级作用域**就是使用一对大括号包裹的一段代码，代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

&emsp;

#### 变量提升所带来的问题

- 变量容易在不被察觉的情况下被覆盖掉（变量覆盖）
- 本应销毁的变量没有被销毁（变量污染）

&emsp;

ES6 通过块级作用域关键字 let 和 const 解决变量提升带来的缺陷。来看下面这个栗子：

~~~ javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
~~~

第一步，编译并创建执行上下文

![JS-block-scope1](assets/JS-block-scope1.png)

通过上图，我们可以得出以下结论：

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境**（Lexical Environment）中。
- 在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中。

&emsp;

第二步，继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：

![JS-block-scope2](assets/JS-block-scope2.png) 从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。 

再接下来，当执行到作用域块中的 console.log(a) 这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。 

![JS-block-scope3](assets/JS-block-scope3.png)

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：

![JS-block-scope4](assets/JS-block-scope4.png)

通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。 