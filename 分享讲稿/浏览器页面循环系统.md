每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理渲染事件，同时还需要处理 JavaScript 脚本以及各种用户交互事件。  要让这么多不同类型的任务在主线程中有条不紊地执行，就需要一个系统来统筹调度这些任务， 这就是下面要讲的消息队列和事件循环系统。 ![event-loop](../assets/event-loop.png)

#### XMLHttpRequest 实现

![xml-http-request](D:\zf7067\Desktop\front end\front-end\分享讲稿\assets\xml-http-request.png)

渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。 

&emsp;

#### setTimeout 实现

setTimeout 是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

> 延迟队列其实是一个 hashmap 结构，等到执行这个结构的时候，会计算 hashmap 中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环

~~~ javascript
void ProcessDelayTask(){
  //从delayed_incoming_queue中取出已经到期的定时器任务
  //依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
~~~

在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用 clearTimeout 函数，并传入需要取消的定时器的 ID。其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。

&emsp;

##### 页面使用单线程的缺点

1. 处理高优先级任务问题

   比如通过监控 DOM 节点的变化，来处理相应的业务逻辑，采用同步通知的方式，会影响当前任务的**执行效率**；如果采用异步方式，又会影响到**监控的实时性**。

   解决方法：引入微任务

   通常我们把消息队列中的任务称为**宏任务**，每个宏任务中都包含了一个**微任务**队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

   等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

&emsp;

#### 微任务

微任务就是一个需要异步执行的函数，执行时机是在**主函数执行结束之后**、当前**宏任务结束之前**。

**微任务产生**

- 使用 MutationObserver 监控某个 DOM 节点，当 DOM 节点发生变化时，就会产生 DOM 变化的微任务
- 使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务  

通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。 

&emsp;

### 结论

所以，每次事件循环中任务执行顺序为：宏任务——>微任务——>延迟任务